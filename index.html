<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ポケモンバトル：カスタムエディション</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- データファイル -->
    <script src="data/pokemon.js"></script>
    <script src="data/moves.js"></script>
    <script src="effects/effects.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        .font-pixel {
            font-family: 'DotGothic16', sans-serif;
        }

        canvas {
            image-rendering: pixelated;
        }

        .log-container::-webkit-scrollbar {
            width: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 10px;
        }

        body {
            background-color: #0f172a;
            overflow-x: hidden;
        }

        .pixel-border {
            box-shadow: 0 4px 0 0 #1e293b;
        }

        /* BGM用iframeを隠す */
        .bgm-player {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>

<body class="min-h-screen flex items-center justify-center p-2 md:p-4">
    <div id="root" class="w-full max-w-2xl"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // ポケモンデータと技データを統合して使用可能な形式に変換
        const getPokemonWithMoves = (pokemonKey) => {
            const pokemon = POKEMON_DATA[pokemonKey];
            if (!pokemon) {
                console.error('ポケモンが見つかりません:', pokemonKey);
                return null;
            }

            const moves = pokemon.moves.map(moveName => {
                const moveData = MOVES_DATA[moveName];
                if (!moveData) {
                    console.error('技データが見つかりません:', moveName, 'ポケモン:', pokemonKey);
                }
                return { name: moveName, ...moveData };
            }).filter(move => move.power !== undefined); // 技データが見つからないものを除外

            if (moves.length === 0) {
                console.error('有効な技が見つかりません:', pokemonKey);
                return null;
            }

            return { ...pokemon, moves };
        };

        const App = () => {
            // --- State ---
            const [gameState, setGameState] = useState('select');
            const [p1, setP1] = useState(null);
            const [p2, setP2] = useState(null);
            const [turn, setTurn] = useState("player");
            const [busy, setBusy] = useState(false);
            const [over, setOver] = useState(false);
            const [logs, setLogs] = useState(["ポケモンを えらんでね！"]);
            const [bgmActive, setBgmActive] = useState(false);

            const [activeEffect, setActiveEffect] = useState(null);
            const [shake, setShake] = useState(0);
            const [p1Action, setP1Action] = useState("idle");
            const [p2Action, setP2Action] = useState("idle");
            const [evolutionEffect, setEvolutionEffect] = useState(null); // 進化演出用
            const [evolutionComplete, setEvolutionComplete] = useState(null); // 進化完了後の表示用
            const [megaScizorFrontImageUrl, setMegaScizorFrontImageUrl] = useState(null); // メガハッサム表画像のURL（背景透過処理済み）

            const canvasRef = useRef(null);
            const imagesRef = useRef({ p1: new Image(), p2: new Image() });
            const basagiriImageRef = useRef(null);
            const evolvedPokemonImageRef = useRef(null);
            const evolvedP1ImageRef = useRef(null); // 進化後のプレイヤーポケモン用
            const megaCharizardBackImageRef = useRef(null); // メガリザードン背後画像用
            const megaLucarioBackImageRef = useRef(null); // メガルカリオ背後画像用
            const megaRayquazaBackImageRef = useRef(null); // メガレックウザ背後画像用
            const megaScizorBackImageRef = useRef(null); // メガハッサム背後画像用（プレイヤー用）
            const megaScizorFrontImageRef = useRef(null); // メガハッサム表画像用（CPU/進化演出用）
            const particles = useRef([]);
            const ballAnimRef = useRef({ active: false, progress: 0, status: 'none', shakeCount: 0 });
            const beamProgressRef = useRef(0);
            const audioRef = useRef(null);
            const audioContextRef = useRef(null);

            // 勝利回数の管理（localStorage使用）
            const getWinCount = (pokemonKey) => {
                const saved = localStorage.getItem(`pokemon_wins_${pokemonKey}`);
                return saved ? parseInt(saved, 10) : 0;
            };

            const setWinCount = (pokemonKey, count) => {
                localStorage.setItem(`pokemon_wins_${pokemonKey}`, count.toString());
            };

            const resetEvolution = (pokemonKey) => {
                localStorage.removeItem(`pokemon_wins_${pokemonKey}`);
            };

            // 進化チェックと実行
            const checkEvolution = async (pokemonKey) => {
                if (!EVOLUTION_MAP[pokemonKey]) return false;

                const evolution = EVOLUTION_MAP[pokemonKey];
                const currentWins = getWinCount(pokemonKey);
                const newWins = currentWins + 1;
                setWinCount(pokemonKey, newWins);

                if (newWins >= evolution.winsNeeded) {
                    // 進化済みフラグを保存
                    localStorage.setItem(`pokemon_evolved_${pokemonKey}`, 'true');

                    // 進化イベント発動
                    setEvolutionEffect({
                        pokemonKey: pokemonKey,
                        evolvedKey: evolution.evolved,
                        oldName: POKEMON_DATA[pokemonKey].name,
                        newName: POKEMON_DATA[evolution.evolved].name,
                        progress: 0
                    });

                    // 進化演出（約7秒）
                    await new Promise(r => setTimeout(r, 400));
                    addLog(`おや？${POKEMON_DATA[pokemonKey].name}の ようすが...`);
                    await new Promise(r => setTimeout(r, 800));

                    // カッコいい照明エフェクト（ゆっくりと光が強くなる）
                    for (let p = 0; p <= 1; p += 0.02) {
                        setEvolutionEffect(prev => prev ? { ...prev, progress: p } : null);
                        await new Promise(r => setTimeout(r, 35));
                    }

                    // 最大輝度を維持（進化後のポケモンを表示）
                    await new Promise(r => setTimeout(r, 1200));

                    addLog(`→${POKEMON_DATA[evolution.evolved].name}に なりました！`);
                    await new Promise(r => setTimeout(r, 800));

                    // エフェクトをフェードアウト
                    for (let p = 1; p >= 0; p -= 0.04) {
                        setEvolutionEffect(prev => prev ? { ...prev, progress: p } : null);
                        await new Promise(r => setTimeout(r, 35));
                    }

                    setEvolutionEffect(null);
                    // 進化完了後の表示を設定
                    setEvolutionComplete({
                        evolvedKey: evolution.evolved,
                        evolvedName: POKEMON_DATA[evolution.evolved].name
                    });
                    return true;
                }
                return false;
            };

            // 進化済みかチェック
            const isEvolved = (pokemonKey) => {
                return localStorage.getItem(`pokemon_evolved_${pokemonKey}`) === 'true';
            };

            // 進化済みポケモンのキーを取得
            const getEvolvedKey = (pokemonKey) => {
                if (!EVOLUTION_MAP[pokemonKey]) return pokemonKey;
                return isEvolved(pokemonKey) ? EVOLUTION_MAP[pokemonKey].evolved : pokemonKey;
            };

            // 全進化をリセット
            const resetAllEvolutions = () => {
                Object.keys(EVOLUTION_MAP).forEach(key => {
                    resetEvolution(key);
                    localStorage.removeItem(`pokemon_evolved_${key}`);
                });
                window.location.reload(); // 画面をリロードして反映
            };

            // メガリザードン背後画像の読み込み（背景透過処理付き）
            useEffect(() => {
                if (!megaCharizardBackImageRef.current) {
                    const img = new Image();
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        megaCharizardBackImageRef.current = canvas;
                    };
                    img.onerror = () => {
                        console.log('メガリザードン背後画像の読み込みに失敗しました');
                    };
                    img.src = 'メガリザードン背後.png';
                }
            }, []);

            // メガルカリオ背後画像の読み込み（背景透過処理付き）
            useEffect(() => {
                if (!megaLucarioBackImageRef.current) {
                    const img = new Image();
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        megaLucarioBackImageRef.current = canvas;
                    };
                    img.onerror = () => {
                        console.log('メガルカリオ背後画像の読み込みに失敗しました');
                    };
                    img.src = 'メガルカリオ背後.png';
                }
            }, []);

            // メガレックウザ背後画像の読み込み（背景透過処理付き）
            useEffect(() => {
                if (!megaRayquazaBackImageRef.current) {
                    const img = new Image();
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        megaRayquazaBackImageRef.current = canvas;
                    };
                    img.onerror = () => {
                        console.log('メガレックウザ背後画像の読み込みに失敗しました');
                    };
                    img.src = 'メガレックウザ.png';
                }
            }, []);

            // メガハッサム背後画像の読み込み（背景透過処理付き、プレイヤー用）
            useEffect(() => {
                if (!megaScizorBackImageRef.current) {
                    const img = new Image();
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        megaScizorBackImageRef.current = canvas;
                    };
                    img.onerror = () => {
                        console.log('メガハッサム背後画像の読み込みに失敗しました');
                    };
                    img.src = 'メガハッサム_背後.png';
                }
            }, []);

            // メガハッサム表画像の読み込み（背景透過処理付き、CPU/進化演出用）
            useEffect(() => {
                if (!megaScizorFrontImageRef.current) {
                    const img = new Image();
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        megaScizorFrontImageRef.current = canvas;
                        // canvas要素を画像URLに変換して保存（選択画面と進化完了後の表示で使用）
                        const imageUrl = canvas.toDataURL('image/png');
                        setMegaScizorFrontImageUrl(imageUrl);
                    };
                    img.onerror = () => {
                        console.log('メガハッサム表画像の読み込みに失敗しました');
                    };
                    img.src = 'メガハッサム_表.png';
                }
            }, []);

            // バサギリの画像を読み込む（背景透過処理付き）
            useEffect(() => {
                if (!basagiriImageRef.current) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        basagiriImageRef.current = canvas;
                    };
                    img.src = 'バサギリ.jpg';
                }
            }, []);

            const addLog = (msg) => {
                setLogs(prev => [msg, ...prev].slice(0, 20));
            };

            const triggerShake = (amount = 10) => {
                setShake(amount);
                setTimeout(() => setShake(0), 500);
            };

            // 音声を開始する（ユーザーインタラクション後に呼び出す）
            const startAudio = () => {
                // Web Audio APIのコンテキストを開始（スマホ対応）
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!audioContextRef.current) {
                        audioContextRef.current = new AudioContext();
                    }
                    // サスペンドされている場合は再開
                    if (audioContextRef.current.state === 'suspended') {
                        audioContextRef.current.resume();
                    }
                } catch (e) {
                    console.log('AudioContext not supported');
                }
            };

            // --- Logic ---
            const startBattle = (p1Key, p2Key) => {
                // 進化済みの場合は進化後のキーを使用
                const actualP1Key = getEvolvedKey(p1Key);
                const char1 = getPokemonWithMoves(actualP1Key);
                const char2 = getPokemonWithMoves(p2Key);
                if (!char1 || !char2) {
                    console.error('ポケモンデータが見つかりません:', { p1Key, p2Key, actualP1Key, char1, char2 });
                    return;
                }

                // 音声を開始（ユーザーインタラクション後なので可能）
                startAudio();

                setP1({ ...char1, curHp: char1.hp, defBoost: 1, atkBoost: 1, key: p1Key, poisoned: false });
                setP2({ ...char2, curHp: char2.hp, defBoost: 1, atkBoost: 1, key: p2Key, poisoned: false });
                setGameState('battle');
                setBgmActive(true); // バトル開始でBGMを有効化
                setLogs([`ゆけっ！ ${char1.name}！`, `野生の ${char2.name}が あらわれた！`]);
                setTurn("player");
                setOver(false);
                ballAnimRef.current = { active: false, progress: 0, status: 'none', shakeCount: 0 };
                beamProgressRef.current = 0;
            };

            const tryCatch = async () => {
                if (busy || over) return;
                setBusy(true);
                setBgmActive(true); // 念のためクリック時にもBGMフラグを立てる
                addLog(`${p1.name}は モンスターボールを 投げた！`);

                ballAnimRef.current = { active: true, progress: 0, status: 'flying', shakeCount: 0 };
                await new Promise(r => setTimeout(r, 1000));

                ballAnimRef.current.status = 'shaking';
                const catchChance = (1 - (p2.curHp / p2.hp)) * 0.7 + 0.15;
                const isSuccess = Math.random() < catchChance;

                for (let i = 1; i <= 3; i++) {
                    await new Promise(r => setTimeout(r, 700));
                    if (!isSuccess && i === Math.floor(Math.random() * 3) + 1) {
                        ballAnimRef.current.active = false;
                        addLog(`だめだ！ ${p2.name}は ボールから ぬけだした！`);
                        triggerShake(5);
                        setP2Action("idle");
                        await new Promise(r => setTimeout(r, 600));
                        setTurn("cpu");
                        setBusy(false);
                        return;
                    }
                    ballAnimRef.current.shakeCount = i;
                }

                addLog(`やったー！ ${p2.name}を つかまえたぞ！`);
                ballAnimRef.current.status = 'success';
                setOver('caught');
                setBusy(false);
            };

            const executeTurn = async (attackerSide, moveIndex) => {
                if (busy || over) return;
                setBusy(true);
                setBgmActive(true);

                const isP1 = attackerSide === "player";
                const attacker = isP1 ? p1 : p2;
                const defender = isP1 ? p2 : p1;
                const setAttacker = isP1 ? setP1 : setP2;
                const setDefender = isP1 ? setP2 : setP1;
                const move = attacker.moves[moveIndex];

                // どく状態のダメージ処理
                if (attacker.poisoned) {
                    const poisonDamage = Math.max(1, Math.floor(attacker.hp * 0.125)); // HPの1/8のダメージ
                    addLog(`${attacker.name}は どくの ダメージを うけた！`);
                    setAttacker(prev => {
                        const newHp = Math.max(0, prev.curHp - poisonDamage);
                        if (newHp <= 0) {
                            setOver(isP1 ? 'lose' : 'win');
                        }
                        return { ...prev, curHp: newHp };
                    });
                    triggerShake(5);
                    await new Promise(r => setTimeout(r, 600));
                    if (over) {
                        setBusy(false);
                        return;
                    }
                }

                addLog(`${attacker.name}の ${move.name}！`);
                await new Promise(r => setTimeout(r, 400));

                const hit = Math.random() * 100 <= move.acc;

                if (!hit) {
                    addLog("しかし こうげきは はずれた！");
                } else if (move.status === "def_up") {
                    setActiveEffect({ type: 'shield', target: isP1 ? 'p1' : 'p2' });
                    addLog(`${attacker.name}の ぼうぎょが あがった！`);
                    setAttacker(prev => ({ ...prev, defBoost: prev.defBoost + 0.5 }));
                    await new Promise(r => setTimeout(r, 800));
                } else if (move.status === "atk_up") {
                    setActiveEffect({ type: 'sparkle', target: isP1 ? 'p1' : 'p2' });
                    addLog(`${attacker.name}は きあいを いれた！ 攻撃UP！`);
                    setAttacker(prev => ({ ...prev, atkBoost: prev.atkBoost + 0.5 }));
                    await new Promise(r => setTimeout(r, 800));
                } else if (move.status === "poison") {
                    setActiveEffect({ type: 'poison', target: isP1 ? 'p2' : 'p1' });
                    addLog(`${defender.name}は どくを うけた！`);
                    // どく状態を適用
                    setDefender(prev => ({ ...prev, poisoned: true }));
                    await new Promise(r => setTimeout(r, 1000));
                } else {
                    // エフェクトの処理
                    if (move.effect === "eternal_beam") {
                        // エターナルビームエフェクト
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 260;
                        const startX = isP1 ? w * 0.05 : w * 0.95;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        // CPUのポケモンにより近い位置に設定（p2はw * 0.65, h * 0.05付近に表示）
                        const targetX = isP1 ? w * 0.75 : w * 0.0;
                        const targetY = isP1 ? h * 0.3 : h * 0.6;

                        setActiveEffect({
                            type: 'eternal_beam',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        for (let p = 0; p <= 1; p += 0.02) {
                            setActiveEffect(prev => {
                                if (!prev || prev.type !== 'eternal_beam') return prev;
                                return { ...prev, progress: p };
                            });
                            await new Promise(r => setTimeout(r, 20));
                        }
                        await new Promise(r => setTimeout(r, 500));
                    } else if (move.effect === "dragon_meteor") {
                        // りゅうせいぐんエフェクト
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        setActiveEffect({
                            type: 'dragon_meteor',
                            target: isP1 ? 'p2' : 'p1',
                            targetX, targetY,
                            progress: 0
                        });

                        for (let p = 0; p <= 1; p += 0.02) {
                            setActiveEffect(prev => {
                                if (!prev || prev.type !== 'dragon_meteor') return prev;
                                return { ...prev, progress: p };
                            });
                            await new Promise(r => setTimeout(r, 30));
                        }
                        await new Promise(r => setTimeout(r, 600));
                    } else if (move.effect === "eternal_storm") {
                        // ムゲンストームエフェクト
                        setActiveEffect({ type: 'eternal_storm', target: isP1 ? 'p2' : 'p1' });
                        await new Promise(r => setTimeout(r, 1200));
                    } else if (move.effect === "poison") {
                        // どくどくエフェクト
                        setActiveEffect({ type: 'poison', target: isP1 ? 'p2' : 'p1' });
                        addLog(`${defender.name}は どくを うけた！`);
                        // どく状態を適用
                        setDefender(prev => ({ ...prev, poisoned: true }));
                        await new Promise(r => setTimeout(r, 1000));
                    } else if (move.effect === "beam") {
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const startX = isP1 ? w * 0.25 : w * 0.75;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        beamProgressRef.current = 0;
                        setActiveEffect({
                            type: 'beam',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        // ビームアニメーション（進行を更新）
                        for (let p = 0; p <= 1; p += 0.05) {
                            beamProgressRef.current = p;
                            setActiveEffect(prev => prev ? { ...prev, progress: p } : null);
                            await new Promise(r => setTimeout(r, 30));
                        }
                        await new Promise(r => setTimeout(r, 300));
                    } else if (move.effect === "shadow_ball") {
                        // シャドーボールエフェクトの処理
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const startX = isP1 ? w * 0.25 : w * 0.75;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        setActiveEffect({
                            type: 'shadow_ball',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        // シャドーボールアニメーション（進行を更新）
                        for (let p = 0; p <= 1; p += 0.02) {
                            setActiveEffect(prev => {
                                if (!prev || prev.type !== 'shadow_ball') return prev;
                                return { ...prev, progress: p };
                            });
                            await new Promise(r => setTimeout(r, 20));
                        }
                        await new Promise(r => setTimeout(r, 500));
                    } else if (move.effect === "zeraora_plasma") {
                        // ゼラオラのプラズマエフェクトの処理
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const startX = isP1 ? w * 0.25 : w * 0.75;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        setActiveEffect({
                            type: 'zeraora_plasma',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        // プラズマアニメーション（進行を更新）
                        for (let p = 0; p <= 1; p += 0.02) {
                            setActiveEffect(prev => {
                                if (!prev || prev.type !== 'zeraora_plasma') return prev;
                                return { ...prev, progress: p };
                            });
                            await new Promise(r => setTimeout(r, 20));
                        }
                        await new Promise(r => setTimeout(r, 500));
                    } else if (move.effect === "zeraora_thunder_punch") {
                        // ゼラオラのかみなりパンチエフェクトの処理
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const startX = isP1 ? w * 0.25 : w * 0.75;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        setActiveEffect({
                            type: 'zeraora_thunder_punch',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        // かみなりパンチアニメーション（進行を更新）
                        for (let p = 0; p <= 1; p += 0.03) {
                            setActiveEffect(prev => {
                                if (!prev || prev.type !== 'zeraora_thunder_punch') return prev;
                                return { ...prev, progress: p };
                            });
                            await new Promise(r => setTimeout(r, 25));
                        }
                        await new Promise(r => setTimeout(r, 400));
                    } else {
                        setActiveEffect({ type: move.type, target: isP1 ? 'p2' : 'p1' });
                    }
                    triggerShake(move.power > 70 ? 15 : 8);
                    await new Promise(r => setTimeout(r, 600));

                    const modifier = (TYPE_CHART[move.type]?.[defender.type] || 1.0) * (move.type === attacker.type ? 1.5 : 1.0);
                    // メガ進化ポケモンの場合は攻撃力を1.5倍に
                    const isMegaEvolved = (attacker.key === 'raichu' || attacker.key === 'mega_rayquaza' || attacker.key === 'mega_charizard' || attacker.key === 'mega_lucario' || attacker.key === 'mega_scizor');
                    const megaMultiplier = isMegaEvolved ? 1.5 : 1.0;
                    const damage = Math.max(1, Math.floor(((move.power * 0.3) * modifier * (0.85 + Math.random() * 0.15) * attacker.atkBoost * megaMultiplier) / defender.defBoost));

                    if (isP1) setP2Action("hit"); else setP1Action("hit");

                    if (modifier > 1) addLog("こうかは ばつぐんだ！");
                    if (modifier < 1) addLog("こうかは いまひとつの ようだ...");

                    setDefender(prev => {
                        const newHp = Math.max(0, prev.curHp - damage);
                        if (newHp <= 0) {
                            if (isP1) {
                                // プレイヤーの勝利
                                setOver('win');
                                // 進化チェック
                                checkEvolution(p1.key);
                            } else {
                                setOver('lose');
                            }
                        }
                        return { ...prev, curHp: newHp };
                    });

                    await new Promise(r => setTimeout(r, 400));
                    setP1Action("idle"); setP2Action("idle");
                }

                setActiveEffect(null);
                await new Promise(r => setTimeout(r, 400));
                if (!over && (isP1 ? p2.curHp > 0 : p1.curHp > 0)) {
                    setTurn(isP1 ? "cpu" : "player");
                }
                setBusy(false);
            };

            // CPU Logic
            useEffect(() => {
                if (gameState === 'battle' && turn === "cpu" && !busy && !over) {
                    const timer = setTimeout(() => {
                        const moveIdx = Math.floor(Math.random() * p2.moves.length);
                        executeTurn("cpu", moveIdx);
                    }, 1200);
                    return () => clearTimeout(timer);
                }
            }, [turn, busy, over, gameState]);

            // --- Canvas Drawing ---
            const drawPokeball = (ctx, x, y, size, rotation, status) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath(); ctx.ellipse(0, size / 2, size / 1.5, size / 4, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, 0, size / 2, 0, Math.PI, false); ctx.fill();
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(0, 0, size / 2, Math.PI, Math.PI * 2, false); ctx.fill();
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, size / 2, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-size / 2, 0); ctx.lineTo(size / 2, 0); ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, 0, size / 6, 0, Math.PI * 2); ctx.fill();
                ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, size / 12, 0, Math.PI * 2); ctx.stroke();
                if (status === 'success') {
                    ctx.shadowBlur = 15; ctx.shadowColor = '#fbbf24'; ctx.stroke();
                }
                ctx.restore();
            };

            useEffect(() => {
                if (gameState !== 'battle') return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let animationId;

                const render = () => {
                    const w = canvas.width, h = canvas.height;
                    ctx.save();
                    if (shake > 0) ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);

                    const gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, '#1e293b'); gradient.addColorStop(1, '#0f172a');
                    ctx.fillStyle = gradient; ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = '#334155';
                    ctx.beginPath(); ctx.ellipse(w * 0.25, h * 0.8, 120, 30, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(w * 0.75, h * 0.35, 90, 20, 0, 0, Math.PI * 2); ctx.fill();

                    const isP2Visible = !(ballAnimRef.current.active && ballAnimRef.current.status !== 'flying');
                    const drawPoke = (img, x, y, size, action) => {
                        ctx.save();
                        if (action === 'hit') { ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)'; ctx.translate((Math.random() - 0.5) * 10, 0); }
                        if (img.complete && img.naturalWidth > 0) ctx.drawImage(img, x, y, size, size);
                        ctx.restore();
                    };

                    const drawBasagiri = (x, y, size, action) => {
                        ctx.save();
                        if (action === 'hit') { ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)'; ctx.translate((Math.random() - 0.5) * 10, 0); }
                        if (basagiriImageRef.current) {
                            ctx.drawImage(basagiriImageRef.current, x, y, size, size);
                        }
                        ctx.restore();
                    };

                    // バサギリ（ID 900）の場合はカスタム画像を使用
                    if (p1.key === 'scyther_alt') {
                        // バサギリのカスタム画像を使用（既に読み込まれている）
                    } else {
                        // 進化済みの場合は特別なURLを使用
                        const actualP1Key = getEvolvedKey(p1.key);
                        // メガリザードン、メガルカリオ、メガハッサムはローカル画像を使用するため、URL設定をスキップ
                        if (actualP1Key !== 'mega_charizard' && actualP1Key !== 'mega_lucario' && actualP1Key !== 'mega_scizor') {
                            let p1ImageUrl;
                            if (p1.key === 'black_rayquaza') {
                                // ブラックレックウザは特別な画像を使用
                                p1ImageUrl = 'https://img.pokemondb.net/sprites/black-white/back-shiny/rayquaza.png';
                            } else if (actualP1Key === 'mega_rayquaza') {
                                p1ImageUrl = 'https://img.pokemondb.net/sprites/black-white/anim/back-normal/rayquaza.gif';
                            } else {
                                p1ImageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/${p1.id}.png`;
                            }

                            // 進化済みの場合は別の画像参照を使用
                            if (actualP1Key !== p1.key && actualP1Key !== 'mega_charizard' && actualP1Key !== 'mega_lucario' && actualP1Key !== 'mega_rayquaza' && actualP1Key !== 'mega_scizor') {
                                if (!evolvedP1ImageRef.current || evolvedP1ImageRef.current.src !== p1ImageUrl) {
                                    const img = new Image();
                                    img.src = p1ImageUrl;
                                    evolvedP1ImageRef.current = img;
                                }
                            } else {
                                if (imagesRef.current.p1.src !== p1ImageUrl) {
                                    imagesRef.current.p1.src = p1ImageUrl;
                                }
                            }
                        }
                    }

                    // CPUポケモンの画像URLを設定（メガハッサムの場合は表画像を使用）
                    if (p2.key === 'mega_scizor') {
                        // メガハッサムはローカル画像を使用するため、URL設定をスキップ
                    } else {
                        imagesRef.current.p2.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p2.id}.png`;
                    }

                    // CPUポケモンの描画（メガハッサムの場合は表画像を使用）
                    if (isP2Visible) {
                        if (p2.key === 'mega_scizor' && megaScizorFrontImageRef.current) {
                            ctx.save();
                            if (p2Action === 'hit') {
                                ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
                                ctx.translate((Math.random() - 0.5) * 10, 0);
                            }
                            if (megaScizorFrontImageRef.current instanceof HTMLCanvasElement) {
                                ctx.drawImage(megaScizorFrontImageRef.current, w * 0.65, h * 0.05, 160, 160);
                            } else if (megaScizorFrontImageRef.current.complete && megaScizorFrontImageRef.current.naturalWidth > 0) {
                                ctx.drawImage(megaScizorFrontImageRef.current, w * 0.65, h * 0.05, 160, 160);
                            }
                            ctx.restore();
                        } else {
                            drawPoke(imagesRef.current.p2, w * 0.65, h * 0.05, 160, p2Action);
                        }
                    }
                    // すべてのプレイヤーポケモンを左上に配置（レックウザと同じ位置）
                    const p1X = w * 0.05;
                    const p1Y = h * 0.4;
                    const p1Size = 220;

                    // バサギリの場合はカスタム画像を描画
                    if (p1.key === 'scyther_alt') {
                        drawBasagiri(p1X, p1Y, p1Size, p1Action);
                    } else {
                        // 進化済みの場合は進化後の画像を使用
                        const actualP1Key = getEvolvedKey(p1.key);

                        // メガリザードン、メガルカリオ、メガレックウザ、メガハッサムはローカル画像を使用
                        if (actualP1Key === 'mega_charizard' && megaCharizardBackImageRef.current) {
                            ctx.save();
                            if (p1Action === 'hit') {
                                ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
                                ctx.translate((Math.random() - 0.5) * 10, 0);
                            }
                            // 画像自体は小さく、横幅を広げて描画（回転なし）
                            const baseSize = p1Size * 0.7; // 30%小さく
                            const drawWidth = baseSize * 1.3; // 横幅を30%広げる
                            const drawHeight = baseSize; // 高さはそのまま
                            const adjustedX = p1X - (drawWidth - p1Size) / 2;
                            const adjustedY = p1Y - (drawHeight - p1Size) / 2;
                            // canvas要素の場合はそのまま描画
                            if (megaCharizardBackImageRef.current instanceof HTMLCanvasElement) {
                                ctx.drawImage(megaCharizardBackImageRef.current, adjustedX, adjustedY, drawWidth, drawHeight);
                            } else if (megaCharizardBackImageRef.current.complete && megaCharizardBackImageRef.current.naturalWidth > 0) {
                                ctx.drawImage(megaCharizardBackImageRef.current, adjustedX, adjustedY, drawWidth, drawHeight);
                            }
                            ctx.restore();
                        } else if (actualP1Key === 'mega_rayquaza' && megaRayquazaBackImageRef.current) {
                            ctx.save();
                            if (p1Action === 'hit') {
                                ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
                                ctx.translate((Math.random() - 0.5) * 10, 0);
                            }
                            // 画像自体は小さく、横幅を広げて描画（回転なし）
                            const baseSize = p1Size * 0.7; // 30%小さく
                            const drawWidth = baseSize * 1.5; // 横幅を50%広げる
                            const drawHeight = baseSize; // 高さはそのまま
                            const adjustedX = p1X - (drawWidth - p1Size) / 2;
                            const adjustedY = p1Y - (drawHeight - p1Size) / 2;
                            // canvas要素の場合はそのまま描画
                            if (megaRayquazaBackImageRef.current instanceof HTMLCanvasElement) {
                                ctx.drawImage(megaRayquazaBackImageRef.current, adjustedX, adjustedY, drawWidth, drawHeight);
                            } else if (megaRayquazaBackImageRef.current.complete && megaRayquazaBackImageRef.current.naturalWidth > 0) {
                                ctx.drawImage(megaRayquazaBackImageRef.current, adjustedX, adjustedY, drawWidth, drawHeight);
                            }
                            ctx.restore();
                        } else if (actualP1Key === 'mega_lucario' && megaLucarioBackImageRef.current) {
                            ctx.save();
                            if (p1Action === 'hit') {
                                ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
                                ctx.translate((Math.random() - 0.5) * 10, 0);
                            }

                            // ピカピカエフェクト（光る効果）
                            const time = Date.now();
                            const sparkleIntensity = 0.3 + Math.sin(time * 0.01) * 0.2; // 0.1〜0.5の間で変化
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = `rgba(59, 130, 246, ${sparkleIntensity})`; // 青い光

                            // そのまま描画（回転なし、元のサイズのまま）
                            if (megaLucarioBackImageRef.current instanceof HTMLCanvasElement) {
                                ctx.drawImage(megaLucarioBackImageRef.current, p1X, p1Y, p1Size, p1Size);
                            } else if (megaLucarioBackImageRef.current.complete && megaLucarioBackImageRef.current.naturalWidth > 0) {
                                ctx.drawImage(megaLucarioBackImageRef.current, p1X, p1Y, p1Size, p1Size);
                            }

                            // 追加の光るエフェクト（複数の光の点）
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = `rgba(255, 255, 255, ${sparkleIntensity * 0.5})`;
                            for (let i = 0; i < 5; i++) {
                                const angle = (time * 0.002 + i * Math.PI * 2 / 5) % (Math.PI * 2);
                                const radius = p1Size * 0.4;
                                const sparkleX = p1X + p1Size / 2 + Math.cos(angle) * radius;
                                const sparkleY = p1Y + p1Size / 2 + Math.sin(angle) * radius;
                                ctx.fillStyle = `rgba(255, 255, 255, ${sparkleIntensity})`;
                                ctx.beginPath();
                                ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }

                            ctx.restore();
                        } else if (actualP1Key === 'mega_scizor' && megaScizorBackImageRef.current) {
                            ctx.save();
                            if (p1Action === 'hit') {
                                ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
                                ctx.translate((Math.random() - 0.5) * 10, 0);
                            }
                            // そのまま描画（背景透過処理済みのcanvas要素を使用）
                            if (megaScizorBackImageRef.current instanceof HTMLCanvasElement) {
                                ctx.drawImage(megaScizorBackImageRef.current, p1X, p1Y, p1Size, p1Size);
                            } else if (megaScizorBackImageRef.current.complete && megaScizorBackImageRef.current.naturalWidth > 0) {
                                ctx.drawImage(megaScizorBackImageRef.current, p1X, p1Y, p1Size, p1Size);
                            }
                            ctx.restore();
                        } else {
                            let p1Image = imagesRef.current.p1;
                            if (actualP1Key !== p1.key && evolvedP1ImageRef.current) {
                                // 進化済みの場合は進化後の画像を使用
                                if (evolvedP1ImageRef.current.complete && evolvedP1ImageRef.current.naturalWidth > 0) {
                                    p1Image = evolvedP1ImageRef.current;
                                }
                            }
                            drawPoke(p1Image, p1X, p1Y, p1Size, p1Action);
                        }
                    }

                    if (ballAnimRef.current.active) {
                        const { status, progress } = ballAnimRef.current;
                        const startX = w * 0.25, startY = h * 0.6;
                        const targetX = w * 0.75, targetY = h * 0.25;

                        if (status === 'flying') {
                            const p = ballAnimRef.current.progress;
                            const curX = startX + (targetX - startX) * p;
                            const curY = startY + (targetY - startY) * p - Math.sin(p * Math.PI) * 100;
                            drawPokeball(ctx, curX, curY, 24, p * Math.PI * 4, 'none');
                            ballAnimRef.current.progress = Math.min(1, p + 0.03);
                        } else {
                            const shakeOffset = Math.sin(Date.now() / 60) * 8;
                            const isActuallyShaking = (Date.now() % 700 < 350);
                            drawPokeball(ctx, targetX, targetY + 30, 24, isActuallyShaking ? shakeOffset * 0.02 : 0, status);
                        }
                    }

                    if (activeEffect) {
                        const tx = activeEffect.target === 'p2' ? w * 0.75 : w * 0.25;
                        const ty = activeEffect.target === 'p2' ? h * 0.25 : h * 0.7;
                        if (window.drawEffect) {
                            window.drawEffect(ctx, activeEffect, tx, ty, w, h);
                        }
                    }

                    // 進化演出（カッコいいエフェクト）
                    if (evolutionEffect) {
                        ctx.save();
                        const time = Date.now();
                        const progress = evolutionEffect.progress || 0;
                        const centerX = w / 2;
                        const centerY = h / 2;

                        // 進化後のポケモンの画像を表示
                        if (evolutionEffect.evolvedKey && progress > 0.3) {
                            const evolvedData = POKEMON_DATA[evolutionEffect.evolvedKey];
                            if (evolvedData) {
                                // メガリザードン、メガレックウザ、メガルカリオ、メガハッサムは特別な画像を使用
                                let pokemonImg = null;
                                if (evolutionEffect.evolvedKey === 'mega_charizard') {
                                    const imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/0c2f066d11c448109862cec46eb62521.png';
                                    if (!evolvedPokemonImageRef.current || evolvedPokemonImageRef.current.src !== imageUrl) {
                                        const img = new Image();
                                        img.onerror = () => {
                                            console.log('画像の読み込みに失敗しました:', imageUrl);
                                        };
                                        img.src = imageUrl;
                                        evolvedPokemonImageRef.current = img;
                                    }
                                    pokemonImg = evolvedPokemonImageRef.current;
                                } else if (evolutionEffect.evolvedKey === 'mega_rayquaza') {
                                    const imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/8ac25cd367875f2ddafc63bd9e0081c4.png';
                                    if (!evolvedPokemonImageRef.current || evolvedPokemonImageRef.current.src !== imageUrl) {
                                        const img = new Image();
                                        img.onerror = () => {
                                            console.log('画像の読み込みに失敗しました:', imageUrl);
                                        };
                                        img.src = imageUrl;
                                        evolvedPokemonImageRef.current = img;
                                    }
                                    pokemonImg = evolvedPokemonImageRef.current;
                                } else if (evolutionEffect.evolvedKey === 'mega_lucario') {
                                    const imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/4e646ee4f6ad9d9ea4b4022f74d63805.png';
                                    if (!evolvedPokemonImageRef.current || evolvedPokemonImageRef.current.src !== imageUrl) {
                                        const img = new Image();
                                        img.onerror = () => {
                                            console.log('画像の読み込みに失敗しました:', imageUrl);
                                        };
                                        img.src = imageUrl;
                                        evolvedPokemonImageRef.current = img;
                                    }
                                    pokemonImg = evolvedPokemonImageRef.current;
                                } else if (evolutionEffect.evolvedKey === 'mega_scizor') {
                                    // メガハッサムは表画像を使用（進化演出用）
                                    pokemonImg = megaScizorFrontImageRef.current;
                                } else {
                                    const imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${evolvedData.id}.png`;
                                    if (!evolvedPokemonImageRef.current || evolvedPokemonImageRef.current.src !== imageUrl) {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        img.onerror = () => {
                                            console.log('画像の読み込みに失敗しました:', imageUrl);
                                        };
                                        img.src = imageUrl;
                                        evolvedPokemonImageRef.current = img;
                                    }
                                    pokemonImg = evolvedPokemonImageRef.current;
                                }
                                // 画像が正常に読み込まれているか確認（エラー状態でないかチェック）
                                if (pokemonImg) {
                                    let isReady = false;
                                    if (pokemonImg instanceof HTMLCanvasElement) {
                                        isReady = true;
                                    } else if (pokemonImg.complete && pokemonImg.naturalWidth > 0 && pokemonImg.naturalHeight > 0) {
                                        isReady = true;
                                    }

                                    if (isReady) {
                                        try {
                                            // 画像をより大きく表示
                                            const baseImgSize = 300;
                                            const imgSize = baseImgSize + Math.sin(time / 80) * 30;
                                            const imgAlpha = Math.min(1, (progress - 0.3) / 0.3);
                                            ctx.globalAlpha = imgAlpha;
                                            ctx.shadowBlur = 50;
                                            ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                                            // 画像の周りに光るエフェクト
                                            ctx.fillStyle = `rgba(255, 255, 255, ${imgAlpha * 0.3})`;
                                            ctx.beginPath();
                                            ctx.arc(centerX, centerY, imgSize / 2 + 20, 0, Math.PI * 2);
                                            ctx.fill();
                                            ctx.drawImage(pokemonImg, centerX - imgSize / 2, centerY - imgSize / 2, imgSize, imgSize);
                                            ctx.globalAlpha = 1;
                                            ctx.shadowBlur = 0;
                                        } catch (e) {
                                            // 描画エラー時は何もしない（CORSエラーなど）
                                            // エラーを無視して進化演出を続行
                                        }
                                    }
                                }
                            }
                        }

                        // 背景の光るエフェクト（より強く）
                        const lightIntensity = Math.min(progress * 1.5, 1);
                        const lightGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h) * 2);
                        lightGradient.addColorStop(0, `rgba(255, 255, 255, ${lightIntensity * 1.0})`);
                        lightGradient.addColorStop(0.15, `rgba(255, 255, 200, ${lightIntensity * 0.9})`);
                        lightGradient.addColorStop(0.3, `rgba(255, 200, 100, ${lightIntensity * 0.7})`);
                        lightGradient.addColorStop(0.5, `rgba(200, 150, 255, ${lightIntensity * 0.5})`);
                        lightGradient.addColorStop(0.7, `rgba(150, 100, 255, ${lightIntensity * 0.3})`);
                        lightGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                        ctx.fillStyle = lightGradient;
                        ctx.fillRect(0, 0, w, h);

                        // 光のリング（複数）
                        for (let i = 0; i < 5; i++) {
                            const ringProgress = Math.max(0, progress - i * 0.15);
                            if (ringProgress > 0) {
                                const baseRingSize = ringProgress * Math.max(w, h) * 0.8;
                                const sinOffset = Math.sin(time / 100 + i) * 20;
                                const ringSize = Math.max(10, baseRingSize + sinOffset); // 最小値10を保証
                                const ringAlpha = Math.max(0, (1 - ringProgress) * 0.6);

                                ctx.strokeStyle = `rgba(255, 255, 255, ${ringAlpha})`;
                                ctx.lineWidth = Math.max(1, 8 - i * 1.2);
                                ctx.shadowBlur = 30;
                                ctx.shadowColor = `rgba(255, 255, 200, ${ringAlpha})`;
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, ringSize, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }

                        // パーティクル（星のような光）
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2 + (time / 50);
                            const distance = progress * Math.max(w, h) * 0.6;
                            const px = centerX + Math.cos(angle) * distance;
                            const py = centerY + Math.sin(angle) * distance;
                            const particleSize = Math.max(2, 5 + Math.sin(time / 100 + i) * 3); // 最小値2を保証
                            const particleAlpha = Math.max(0, (1 - progress) * 0.8);

                            ctx.fillStyle = `rgba(255, 255, 200, ${particleAlpha})`;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                            ctx.beginPath();
                            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // 中心からの光のビーム
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2 + (time / 200);
                            const beamLength = progress * Math.max(w, h) * 0.7;
                            const endX = centerX + Math.cos(angle) * beamLength;
                            const endY = centerY + Math.sin(angle) * beamLength;

                            const beamGradient = ctx.createLinearGradient(centerX, centerY, endX, endY);
                            beamGradient.addColorStop(0, `rgba(255, 255, 255, ${progress * 0.8})`);
                            beamGradient.addColorStop(0.5, `rgba(255, 255, 200, ${progress * 0.5})`);
                            beamGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

                            ctx.strokeStyle = beamGradient;
                            ctx.lineWidth = 4;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        }

                        // 中心の光るコア
                        const coreSize = Math.max(20, 30 + Math.sin(time / 50) * 10); // 最小値20を保証
                        const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
                        coreGradient.addColorStop(0, `rgba(255, 255, 255, ${Math.max(0, Math.min(1, progress))})`);
                        coreGradient.addColorStop(0.5, `rgba(255, 255, 200, ${Math.max(0, Math.min(1, progress * 0.7))})`);
                        coreGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                    }

                    const drawStatus = (x, y, data) => {
                        ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.roundRect(x, y, 220, 70, 12); ctx.fill(); ctx.stroke();

                        // ポケモン名の表示
                        ctx.fillStyle = '#1e293b'; ctx.font = 'bold 18px DotGothic16';
                        const nameText = data.name;
                        ctx.fillText(nameText, x + 15, y + 25);

                        // どく状態の表示（名前の隣にラベルで表示）
                        if (data.poisoned) {
                            const nameWidth = ctx.measureText(nameText).width;
                            const poisonX = x + 15 + nameWidth + 10;
                            const poisonY = y + 25;
                            const labelPadding = 8;
                            const labelHeight = 22;
                            const labelMarginTop = 4; // 上に4pxの余白

                            // 「どく」の文字幅を測定
                            ctx.font = 'bold 14px DotGothic16';
                            const poisonText = 'どく';
                            const textWidth = ctx.measureText(poisonText).width;
                            const labelWidth = textWidth + labelPadding * 2;
                            const labelY = poisonY - labelHeight + labelMarginTop;

                            // 角丸のラベル背景
                            ctx.fillStyle = '#a855f7';
                            ctx.beginPath();
                            ctx.roundRect(poisonX, labelY, labelWidth, labelHeight, 6);
                            ctx.fill();

                            // 白い枠線
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(poisonX, labelY, labelWidth, labelHeight, 6);
                            ctx.stroke();

                            // 「どく」の文字
                            ctx.fillStyle = '#ffffff';
                            ctx.font = 'bold 14px DotGothic16';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(poisonText, poisonX + labelPadding, labelY + labelHeight / 2);
                            ctx.textBaseline = 'alphabetic';
                        }

                        ctx.fillStyle = '#cbd5e1'; ctx.fillRect(x + 15, y + 40, 190, 12);
                        const hpP = data.curHp / data.hp;
                        ctx.fillStyle = hpP > 0.5 ? '#22c55e' : hpP > 0.2 ? '#eab308' : '#ef4444';
                        ctx.fillRect(x + 15, y + 40, 190 * hpP, 12);
                        // HP表示
                        ctx.fillStyle = '#64748b'; ctx.font = '12px monospace';
                        const hpText = `${Math.ceil(data.curHp)}/${data.hp}`;
                        ctx.fillText(hpText, x + 15, y + 65);
                        ctx.restore();
                    };
                    drawStatus(30, 40, p2); drawStatus(w - 250, h - 110, p1);

                    ctx.restore();
                    animationId = requestAnimationFrame(render);
                };
                render();
                return () => cancelAnimationFrame(animationId);
            }, [gameState, p1, p2, activeEffect, shake, p1Action, p2Action, evolutionEffect]);

            // --- UI Components ---
            if (gameState === 'select') {
                return (
                    <div className="bg-slate-800 rounded-3xl border-4 border-slate-700 shadow-2xl text-white font-pixel flex flex-col max-h-[90vh] md:max-h-[85vh]">
                        <div className="p-4 md:p-6 pb-2 md:pb-4 flex-shrink-0">
                            <h1 className="text-2xl md:text-3xl text-center text-yellow-400 drop-shadow-md">ポケモンを えらぼう！</h1>
                        </div>
                        <div className="overflow-y-auto px-4 md:px-6 pb-4 md:pb-6 flex-1">
                            <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4">
                                {Object.entries(POKEMON_DATA).map(([key, data]) => {
                                    const evolvedKeys = Object.values(EVOLUTION_MAP).map(e => e.evolved);

                                    // 進化系のポケモンで、対応する進化前のポケモンが進化済みの場合は表示
                                    if (evolvedKeys.includes(key)) {
                                        // この進化系ポケモンに対応する進化前のポケモンを探す
                                        const baseKey = Object.keys(EVOLUTION_MAP).find(k => EVOLUTION_MAP[k].evolved === key);
                                        if (baseKey && isEvolved(baseKey)) {
                                            // 進化済みなので進化後のポケモンを表示
                                            // メガリザードン、メガレックウザ、メガルカリオは特別なURLを使用
                                            let imageUrl;
                                            if (key === 'mega_charizard') {
                                                imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/0c2f066d11c448109862cec46eb62521.png';
                                            } else if (key === 'mega_rayquaza') {
                                                imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/8ac25cd367875f2ddafc63bd9e0081c4.png';
                                            } else if (key === 'mega_lucario') {
                                                imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/4e646ee4f6ad9d9ea4b4022f74d63805.png';
                                            } else if (key === 'mega_scizor') {
                                                imageUrl = megaScizorFrontImageUrl || 'メガハッサム_表.png';
                                            } else {
                                                imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${data.id}.png`;
                                            }

                                            return (
                                                <button
                                                    key={key}
                                                    onClick={() => {
                                                        const allKeys = Object.keys(POKEMON_DATA).filter(k => {
                                                            if (evolvedKeys.includes(k)) {
                                                                const baseK = Object.keys(EVOLUTION_MAP).find(bk => EVOLUTION_MAP[bk].evolved === k);
                                                                return baseK && isEvolved(baseK) ? k !== key : false;
                                                            }
                                                            const evoKey = getEvolvedKey(k);
                                                            return evoKey !== key;
                                                        });
                                                        const randomKey = allKeys[Math.floor(Math.random() * allKeys.length)];
                                                        startBattle(key, randomKey);
                                                    }}
                                                    className="bg-slate-700 hover:bg-slate-600 border-4 border-transparent hover:border-yellow-400 p-4 rounded-2xl transition-all group flex flex-col items-center relative"
                                                >
                                                    <img src={imageUrl} className="w-32 h-32 group-hover:scale-110 transition-transform" />
                                                    <span className="text-xl mt-2">{data.name}</span>
                                                    <span className="text-xs text-slate-400 uppercase">{data.type} TYPE</span>
                                                </button>
                                            );
                                        }
                                        return null;
                                    }

                                    // 進化前のポケモンで、進化済みの場合はスキップ（進化後のポケモンが表示されるため）
                                    if (EVOLUTION_MAP[key] && isEvolved(key)) {
                                        return null;
                                    }

                                    // 進化前のポケモンで未進化の場合のみ表示
                                    if (EVOLUTION_MAP[key] && !isEvolved(key)) {
                                        const displayKey = getEvolvedKey(key);
                                        const displayData = POKEMON_DATA[displayKey] || data;
                                        // メガリザードン、メガレックウザ、メガルカリオ、メガハッサムは特別な画像を使用
                                        let imageUrl;
                                        if (displayKey === 'mega_charizard') {
                                            imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/0c2f066d11c448109862cec46eb62521.png';
                                        } else if (displayKey === 'mega_rayquaza') {
                                            imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/8ac25cd367875f2ddafc63bd9e0081c4.png';
                                        } else if (displayKey === 'mega_lucario') {
                                            imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/4e646ee4f6ad9d9ea4b4022f74d63805.png';
                                        } else if (displayKey === 'mega_scizor') {
                                            imageUrl = megaScizorFrontImageUrl || 'メガハッサム_表.png';
                                        } else {
                                            imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${displayData.id}.png`;
                                        }

                                        return (
                                            <button
                                                key={key}
                                                onClick={() => {
                                                    const allKeys = Object.keys(POKEMON_DATA).filter(k => {
                                                        if (evolvedKeys.includes(k)) {
                                                            const baseK = Object.keys(EVOLUTION_MAP).find(bk => EVOLUTION_MAP[bk].evolved === k);
                                                            return baseK && isEvolved(baseK) ? k !== displayKey : false;
                                                        }
                                                        const evoKey = getEvolvedKey(k);
                                                        return evoKey !== displayKey;
                                                    });
                                                    const randomKey = allKeys[Math.floor(Math.random() * allKeys.length)];
                                                    startBattle(displayKey, randomKey);
                                                }}
                                                className="bg-slate-700 hover:bg-slate-600 border-4 border-transparent hover:border-yellow-400 p-4 rounded-2xl transition-all group flex flex-col items-center relative"
                                            >
                                                <img src={imageUrl} className="w-32 h-32 group-hover:scale-110 transition-transform" />
                                                <span className="text-xl mt-2">{displayData.name}</span>
                                                <span className="text-xs text-slate-400 uppercase">{displayData.type} TYPE</span>
                                            </button>
                                        );
                                    }

                                    // 進化できないポケモンはそのまま表示
                                    // ブラックレックウザは特別な画像を使用
                                    let imageUrl;
                                    if (key === 'black_rayquaza') {
                                        imageUrl = 'https://img.pokemondb.net/sprites/black-white/shiny/rayquaza.png';
                                    } else {
                                        imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${data.id}.png`;
                                    }

                                    return (
                                        <button
                                            key={key}
                                            onClick={() => {
                                                const allKeys = Object.keys(POKEMON_DATA).filter(k => {
                                                    if (evolvedKeys.includes(k)) {
                                                        const baseK = Object.keys(EVOLUTION_MAP).find(bk => EVOLUTION_MAP[bk].evolved === k);
                                                        return baseK && isEvolved(baseK) ? k !== key : false;
                                                    }
                                                    const evoKey = getEvolvedKey(k);
                                                    return evoKey !== key;
                                                });
                                                const randomKey = allKeys[Math.floor(Math.random() * allKeys.length)];
                                                startBattle(key, randomKey);
                                            }}
                                            className="bg-slate-700 hover:bg-slate-600 border-4 border-transparent hover:border-yellow-400 p-4 rounded-2xl transition-all group flex flex-col items-center"
                                        >
                                            <img src={imageUrl} className="w-32 h-32 group-hover:scale-110 transition-transform" />
                                            <span className="text-xl mt-2">{data.name}</span>
                                            <span className="text-xs text-slate-400 uppercase">{data.type} TYPE</span>
                                        </button>
                                    );
                                })}
                            </div>
                            {/* 進化済みのポケモンがある場合のみリセットボタンを表示（進化演出中は非表示） */}
                            {Object.keys(EVOLUTION_MAP).some(key => isEvolved(key)) && !evolutionEffect && (
                                <div className="mt-4 flex justify-center">
                                    <button
                                        onClick={resetAllEvolutions}
                                        className="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-xl font-bold transition-all font-pixel border-2 border-red-500"
                                    >
                                        進化をリセット
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            return (
                <div className="bg-slate-800 rounded-3xl shadow-2xl overflow-hidden border-4 border-slate-600 select-none">
                    {/* BGM Player (YouTube IFrame - ユーザーインタラクション後に表示) */}
                    {bgmActive && (
                        <iframe
                            className="bgm-player"
                            src="https://www.youtube.com/embed/Q53CDIGPJ58?start=407&end=492&autoplay=1&loop=1&playlist=Q53CDIGPJ58&enablejsapi=1"
                            allow="autoplay; encrypted-media"
                            allowFullScreen={false}
                            onLoad={() => {
                                // iframeが読み込まれた後に音声コンテキストを開始
                                startAudio();
                            }}
                        ></iframe>
                    )}

                    {/* Header */}
                    <div className="bg-slate-900 p-3 text-white flex justify-between items-center px-4 md:px-8 border-b-2 border-slate-700">
                        <div className="flex items-center gap-2">
                            <div className={`w-3 h-3 rounded-full ${turn === 'player' ? 'bg-green-400 animate-pulse' : 'bg-slate-600'}`}></div>
                            <span className="text-sm font-bold tracking-widest">{p1.name}</span>
                        </div>
                        <span className="text-xs font-mono opacity-50 italic">VS WILD {p2.name}</span>
                    </div>

                    {/* Battle Canvas */}
                    <div className="relative bg-black overflow-hidden aspect-video">
                        <canvas ref={canvasRef} width={640} height={360} className="w-full h-full object-contain" />
                        {/* 進化完了後の表示 */}
                        {evolutionComplete && (
                            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center text-white p-2 sm:p-4 animate-in fade-in duration-500 overflow-hidden">
                                <div className="flex flex-col items-center justify-center w-full h-full max-w-full">
                                    {(() => {
                                        const evolvedData = POKEMON_DATA[evolutionComplete.evolvedKey];
                                        let imageUrl;
                                        if (evolutionComplete.evolvedKey === 'mega_charizard') {
                                            imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/0c2f066d11c448109862cec46eb62521.png';
                                        } else if (evolutionComplete.evolvedKey === 'mega_rayquaza') {
                                            imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/8ac25cd367875f2ddafc63bd9e0081c4.png';
                                        } else if (evolutionComplete.evolvedKey === 'mega_lucario') {
                                            imageUrl = 'https://zukan.pokemon.co.jp/zukan-api/up/images/index/4e646ee4f6ad9d9ea4b4022f74d63805.png';
                                        } else if (evolutionComplete.evolvedKey === 'mega_scizor') {
                                            imageUrl = megaScizorFrontImageUrl || 'メガハッサム_表.png';
                                        } else {
                                            imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${evolvedData.id}.png`;
                                        }
                                        return (
                                            <>
                                                <div className="w-full flex justify-center items-center mb-2 sm:mb-3 md:mb-4 flex-shrink-0" style={{ minHeight: '60px', maxHeight: '20vh' }}>
                                                    <img
                                                        src={imageUrl}
                                                        className="w-[80px] h-[80px] sm:w-[110px] sm:h-[110px] md:w-[160px] md:h-[160px] lg:w-[240px] lg:h-[240px] object-contain drop-shadow-2xl animate-pulse"
                                                        style={{
                                                            filter: 'drop-shadow(0 0 30px rgba(255, 255, 255, 0.8))',
                                                            maxWidth: '40vw',
                                                            maxHeight: '18vh',
                                                            width: 'auto',
                                                            height: 'auto'
                                                        }}
                                                        alt={evolutionComplete.evolvedName}
                                                    />
                                                </div>
                                                <h2 className="text-lg sm:text-xl md:text-2xl lg:text-3xl font-black mb-2 sm:mb-3 md:mb-6 font-pixel text-yellow-400 italic text-center drop-shadow-lg px-2 flex-shrink-0">
                                                    {evolutionComplete.evolvedName}
                                                </h2>
                                                <button
                                                    onClick={() => {
                                                        setGameState('select');
                                                        setBgmActive(false);
                                                        setEvolutionComplete(null);
                                                    }}
                                                    className="bg-white text-slate-900 px-4 py-1 sm:px-5 sm:py-1.5 md:px-7 md:py-2 rounded-full font-bold hover:bg-yellow-400 transition-all shadow-xl font-pixel text-xs sm:text-sm md:text-base flex-shrink-0"
                                                >
                                                    タイトルに戻る
                                                </button>
                                            </>
                                        );
                                    })()}
                                </div>
                            </div>
                        )}
                        {over && !evolutionComplete && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center text-white p-4 animate-in fade-in duration-500">
                                <h2 className="text-5xl font-black mb-6 font-pixel text-yellow-400 italic text-center">
                                    {over === 'win' ? "勝利！" : over === 'caught' ? "つかまえた！" : "敗北..."}
                                </h2>
                                {/* 進化演出中はボタンを非表示 */}
                                {!evolutionEffect && (
                                    <button
                                        onClick={() => { setGameState('select'); setBgmActive(false); }}
                                        className="bg-white text-slate-900 px-10 py-3 rounded-full font-bold hover:bg-yellow-400 transition-all shadow-xl font-pixel"
                                    >
                                        タイトルに戻る
                                    </button>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Log Display */}
                    <div className="bg-slate-900 p-4 border-t-4 border-slate-700 h-32 md:h-40 font-pixel flex items-center shadow-inner">
                        <div className="text-white text-xl md:text-2xl border-l-4 border-yellow-500 pl-3">
                            {logs[0] || "ポケモンを えらんでね！"}
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-0 border-t-4 border-slate-700 bg-slate-800">
                        {/* Move Set */}
                        <div className="grid grid-cols-2 gap-2 p-3 md:p-4 bg-slate-900/50 border-r-0 md:border-r-4 border-slate-700">
                            {p1.moves.map((move, idx) => (
                                <button
                                    key={move.name}
                                    onClick={() => executeTurn("player", idx)}
                                    disabled={turn !== "player" || busy || over}
                                    className={`p-3 md:p-4 text-xs md:text-sm font-bold rounded-xl border-2 transition-all pixel-border whitespace-nowrap ${turn === "player" && !busy && !over ? "bg-slate-700 text-white border-slate-500 hover:border-yellow-400 active:translate-y-1" : "bg-slate-800 text-slate-600 border-transparent opacity-50"}`}
                                >
                                    {move.name}
                                </button>
                            ))}
                        </div>
                        {/* Sub Options */}
                        <div className="grid grid-cols-2 p-3 md:p-4 gap-2 md:gap-3 bg-slate-800">
                            <button
                                onClick={tryCatch}
                                disabled={turn !== "player" || busy || over}
                                className={`col-span-2 p-2 md:p-3 font-bold rounded-xl border-2 transition-all font-pixel text-sm shadow-lg ${turn === 'player' && !busy && !over ? 'bg-red-600 text-white border-red-400 hover:bg-red-500 active:translate-y-1' : 'bg-slate-800 text-slate-600 border-transparent opacity-50'}`}
                            >
                                モンスターボール
                            </button>
                            <button onClick={() => { setGameState('select'); setBgmActive(false); }} className="bg-slate-700 hover:bg-red-900 text-slate-300 hover:text-white border-2 border-slate-600 p-2 text-xs font-bold rounded-xl transition-all">にげる</button>
                            <div className="flex items-center justify-center bg-slate-900/40 rounded-xl border border-slate-700">
                                <span className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">{turn === "player" ? "Your Turn" : "CPU..."}</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>