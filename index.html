<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ポケモンバトル：カスタムエディション</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- データファイル -->
    <script src="data/pokemon.js"></script>
    <script src="data/moves.js"></script>
    <script src="effects/effects.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        .font-pixel {
            font-family: 'DotGothic16', sans-serif;
        }

        canvas {
            image-rendering: pixelated;
        }

        .log-container::-webkit-scrollbar {
            width: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 10px;
        }

        body {
            background-color: #0f172a;
            overflow-x: hidden;
        }

        .pixel-border {
            box-shadow: 0 4px 0 0 #1e293b;
        }

        /* BGM用iframeを隠す */
        .bgm-player {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>

<body class="min-h-screen flex items-center justify-center p-2 md:p-4">
    <div id="root" class="w-full max-w-2xl"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // ポケモンデータと技データを統合して使用可能な形式に変換
        const getPokemonWithMoves = (pokemonKey) => {
            const pokemon = POKEMON_DATA[pokemonKey];
            if (!pokemon) {
                console.error('ポケモンが見つかりません:', pokemonKey);
                return null;
            }

            const moves = pokemon.moves.map(moveName => {
                const moveData = MOVES_DATA[moveName];
                if (!moveData) {
                    console.error('技データが見つかりません:', moveName, 'ポケモン:', pokemonKey);
                }
                return { name: moveName, ...moveData };
            }).filter(move => move.power !== undefined); // 技データが見つからないものを除外

            if (moves.length === 0) {
                console.error('有効な技が見つかりません:', pokemonKey);
                return null;
            }

            return { ...pokemon, moves };
        };

        const App = () => {
            // --- State ---
            const [gameState, setGameState] = useState('select');
            const [p1, setP1] = useState(null);
            const [p2, setP2] = useState(null);
            const [turn, setTurn] = useState("player");
            const [busy, setBusy] = useState(false);
            const [over, setOver] = useState(false);
            const [logs, setLogs] = useState(["ポケモンを えらんでね！"]);
            const [bgmActive, setBgmActive] = useState(false);

            const [activeEffect, setActiveEffect] = useState(null);
            const [shake, setShake] = useState(0);
            const [p1Action, setP1Action] = useState("idle");
            const [p2Action, setP2Action] = useState("idle");

            const canvasRef = useRef(null);
            const imagesRef = useRef({ p1: new Image(), p2: new Image() });
            const basagiriImageRef = useRef(null);
            const particles = useRef([]);
            const ballAnimRef = useRef({ active: false, progress: 0, status: 'none', shakeCount: 0 });
            const beamProgressRef = useRef(0);
            const audioRef = useRef(null);
            const audioContextRef = useRef(null);

            // バサギリの画像を読み込む（背景透過処理付き）
            useEffect(() => {
                if (!basagiriImageRef.current) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        // 背景透過処理
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 白い背景を透過させる
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            // 白に近い色（閾値調整可能）を透過させる
                            if (r > 240 && g > 240 && b > 240) {
                                data[i + 3] = 0; // アルファチャンネルを0に
                            }
                        }

                        ctx.putImageData(imageData, 0, 0);
                        basagiriImageRef.current = canvas;
                    };
                    img.src = 'バサギリ.jpg';
                }
            }, []);

            const addLog = (msg) => {
                setLogs(prev => [msg, ...prev].slice(0, 20));
            };

            const triggerShake = (amount = 10) => {
                setShake(amount);
                setTimeout(() => setShake(0), 500);
            };

            // 音声を開始する（ユーザーインタラクション後に呼び出す）
            const startAudio = () => {
                // Web Audio APIのコンテキストを開始（スマホ対応）
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!audioContextRef.current) {
                        audioContextRef.current = new AudioContext();
                    }
                    // サスペンドされている場合は再開
                    if (audioContextRef.current.state === 'suspended') {
                        audioContextRef.current.resume();
                    }
                } catch (e) {
                    console.log('AudioContext not supported');
                }
            };

            // --- Logic ---
            const startBattle = (p1Key, p2Key) => {
                const char1 = getPokemonWithMoves(p1Key);
                const char2 = getPokemonWithMoves(p2Key);
                if (!char1 || !char2) {
                    console.error('ポケモンデータが見つかりません:', { p1Key, p2Key, char1, char2 });
                    return;
                }

                // 音声を開始（ユーザーインタラクション後なので可能）
                startAudio();

                setP1({ ...char1, curHp: char1.hp, defBoost: 1, atkBoost: 1, key: p1Key });
                setP2({ ...char2, curHp: char2.hp, defBoost: 1, atkBoost: 1, key: p2Key });
                setGameState('battle');
                setBgmActive(true); // バトル開始でBGMを有効化
                setLogs([`ゆけっ！ ${char1.name}！`, `野生の ${char2.name}が あらわれた！`]);
                setTurn("player");
                setOver(false);
                ballAnimRef.current = { active: false, progress: 0, status: 'none', shakeCount: 0 };
                beamProgressRef.current = 0;
            };

            const tryCatch = async () => {
                if (busy || over) return;
                setBusy(true);
                setBgmActive(true); // 念のためクリック時にもBGMフラグを立てる
                addLog(`${p1.name}は モンスターボールを 投げた！`);

                ballAnimRef.current = { active: true, progress: 0, status: 'flying', shakeCount: 0 };
                await new Promise(r => setTimeout(r, 1000));

                ballAnimRef.current.status = 'shaking';
                const catchChance = (1 - (p2.curHp / p2.hp)) * 0.7 + 0.15;
                const isSuccess = Math.random() < catchChance;

                for (let i = 1; i <= 3; i++) {
                    await new Promise(r => setTimeout(r, 700));
                    if (!isSuccess && i === Math.floor(Math.random() * 3) + 1) {
                        ballAnimRef.current.active = false;
                        addLog(`だめだ！ ${p2.name}は ボールから ぬけだした！`);
                        triggerShake(5);
                        setP2Action("idle");
                        await new Promise(r => setTimeout(r, 600));
                        setTurn("cpu");
                        setBusy(false);
                        return;
                    }
                    ballAnimRef.current.shakeCount = i;
                }

                addLog(`やったー！ ${p2.name}を つかまえたぞ！`);
                ballAnimRef.current.status = 'success';
                setOver('caught');
                setBusy(false);
            };

            const executeTurn = async (attackerSide, moveIndex) => {
                if (busy || over) return;
                setBusy(true);
                setBgmActive(true);

                const isP1 = attackerSide === "player";
                const attacker = isP1 ? p1 : p2;
                const defender = isP1 ? p2 : p1;
                const setAttacker = isP1 ? setP1 : setP2;
                const setDefender = isP1 ? setP2 : setP1;
                const move = attacker.moves[moveIndex];

                addLog(`${attacker.name}の ${move.name}！`);
                await new Promise(r => setTimeout(r, 400));

                const hit = Math.random() * 100 <= move.acc;

                if (!hit) {
                    addLog("しかし こうげきは はずれた！");
                } else if (move.status === "def_up") {
                    setActiveEffect({ type: 'shield', target: isP1 ? 'p1' : 'p2' });
                    addLog(`${attacker.name}の ぼうぎょが あがった！`);
                    setAttacker(prev => ({ ...prev, defBoost: prev.defBoost + 0.5 }));
                    await new Promise(r => setTimeout(r, 800));
                } else if (move.status === "atk_up") {
                    setActiveEffect({ type: 'sparkle', target: isP1 ? 'p1' : 'p2' });
                    addLog(`${attacker.name}は きあいを いれた！ 攻撃UP！`);
                    setAttacker(prev => ({ ...prev, atkBoost: prev.atkBoost + 0.5 }));
                    await new Promise(r => setTimeout(r, 800));
                } else {
                    // ビームエフェクトの場合は特別な処理
                    if (move.effect === "beam") {
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const startX = isP1 ? w * 0.25 : w * 0.75;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        beamProgressRef.current = 0;
                        setActiveEffect({
                            type: 'beam',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        // ビームアニメーション（進行を更新）
                        for (let p = 0; p <= 1; p += 0.05) {
                            beamProgressRef.current = p;
                            setActiveEffect(prev => prev ? { ...prev, progress: p } : null);
                            await new Promise(r => setTimeout(r, 30));
                        }
                        await new Promise(r => setTimeout(r, 300));
                    } else if (move.effect === "shadow_ball") {
                        // シャドーボールエフェクトの処理
                        const w = canvasRef.current?.width || 640;
                        const h = canvasRef.current?.height || 360;
                        const startX = isP1 ? w * 0.25 : w * 0.75;
                        const startY = isP1 ? h * 0.7 : h * 0.25;
                        const targetX = isP1 ? w * 0.75 : w * 0.25;
                        const targetY = isP1 ? h * 0.25 : h * 0.7;

                        setActiveEffect({
                            type: 'shadow_ball',
                            target: isP1 ? 'p2' : 'p1',
                            startX, startY, targetX, targetY,
                            progress: 0
                        });

                        // シャドーボールアニメーション（進行を更新）
                        for (let p = 0; p <= 1; p += 0.02) {
                            setActiveEffect(prev => {
                                if (!prev || prev.type !== 'shadow_ball') return prev;
                                return { ...prev, progress: p };
                            });
                            await new Promise(r => setTimeout(r, 20));
                        }
                        await new Promise(r => setTimeout(r, 500));
                    } else {
                        setActiveEffect({ type: move.type, target: isP1 ? 'p2' : 'p1' });
                    }
                    triggerShake(move.power > 70 ? 15 : 8);
                    await new Promise(r => setTimeout(r, 600));

                    const modifier = (TYPE_CHART[move.type]?.[defender.type] || 1.0) * (move.type === attacker.type ? 1.5 : 1.0);
                    const damage = Math.max(1, Math.floor(((move.power * 0.3) * modifier * (0.85 + Math.random() * 0.15) * attacker.atkBoost) / defender.defBoost));

                    if (isP1) setP2Action("hit"); else setP1Action("hit");

                    if (modifier > 1) addLog("こうかは ばつぐんだ！");
                    if (modifier < 1) addLog("こうかは いまひとつの ようだ...");

                    setDefender(prev => {
                        const newHp = Math.max(0, prev.curHp - damage);
                        if (newHp <= 0) setOver(isP1 ? 'win' : 'lose');
                        return { ...prev, curHp: newHp };
                    });

                    await new Promise(r => setTimeout(r, 400));
                    setP1Action("idle"); setP2Action("idle");
                }

                setActiveEffect(null);
                await new Promise(r => setTimeout(r, 400));
                if (!over && (isP1 ? p2.curHp > 0 : p1.curHp > 0)) {
                    setTurn(isP1 ? "cpu" : "player");
                }
                setBusy(false);
            };

            // CPU Logic
            useEffect(() => {
                if (gameState === 'battle' && turn === "cpu" && !busy && !over) {
                    const timer = setTimeout(() => {
                        const moveIdx = Math.floor(Math.random() * p2.moves.length);
                        executeTurn("cpu", moveIdx);
                    }, 1200);
                    return () => clearTimeout(timer);
                }
            }, [turn, busy, over, gameState]);

            // --- Canvas Drawing ---
            const drawPokeball = (ctx, x, y, size, rotation, status) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath(); ctx.ellipse(0, size / 2, size / 1.5, size / 4, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, 0, size / 2, 0, Math.PI, false); ctx.fill();
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(0, 0, size / 2, Math.PI, Math.PI * 2, false); ctx.fill();
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, size / 2, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-size / 2, 0); ctx.lineTo(size / 2, 0); ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, 0, size / 6, 0, Math.PI * 2); ctx.fill();
                ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, size / 12, 0, Math.PI * 2); ctx.stroke();
                if (status === 'success') {
                    ctx.shadowBlur = 15; ctx.shadowColor = '#fbbf24'; ctx.stroke();
                }
                ctx.restore();
            };

            useEffect(() => {
                if (gameState !== 'battle') return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let animationId;

                const render = () => {
                    const w = canvas.width, h = canvas.height;
                    ctx.save();
                    if (shake > 0) ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);

                    const gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, '#1e293b'); gradient.addColorStop(1, '#0f172a');
                    ctx.fillStyle = gradient; ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = '#334155';
                    ctx.beginPath(); ctx.ellipse(w * 0.25, h * 0.8, 120, 30, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(w * 0.75, h * 0.35, 90, 20, 0, 0, Math.PI * 2); ctx.fill();

                    const isP2Visible = !(ballAnimRef.current.active && ballAnimRef.current.status !== 'flying');
                    const drawPoke = (img, x, y, size, action) => {
                        ctx.save();
                        if (action === 'hit') { ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)'; ctx.translate((Math.random() - 0.5) * 10, 0); }
                        if (img.complete && img.naturalWidth > 0) ctx.drawImage(img, x, y, size, size);
                        ctx.restore();
                    };

                    const drawBasagiri = (x, y, size, action) => {
                        ctx.save();
                        if (action === 'hit') { ctx.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)'; ctx.translate((Math.random() - 0.5) * 10, 0); }
                        if (basagiriImageRef.current) {
                            ctx.drawImage(basagiriImageRef.current, x, y, size, size);
                        }
                        ctx.restore();
                    };

                    // バサギリ（ID 900）の場合はカスタム画像を使用
                    if (p1.key === 'scyther_alt') {
                        // バサギリのカスタム画像を使用（既に読み込まれている）
                    } else {
                        imagesRef.current.p1.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/${p1.id}.png`;
                    }

                    imagesRef.current.p2.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p2.id}.png`;

                    if (isP2Visible) drawPoke(imagesRef.current.p2, w * 0.65, h * 0.05, 160, p2Action);
                    // すべてのプレイヤーポケモンを左上に配置（レックウザと同じ位置）
                    const p1X = w * 0.05;
                    const p1Y = h * 0.4;
                    const p1Size = 220;

                    // バサギリの場合はカスタム画像を描画
                    if (p1.key === 'scyther_alt') {
                        drawBasagiri(p1X, p1Y, p1Size, p1Action);
                    } else {
                        drawPoke(imagesRef.current.p1, p1X, p1Y, p1Size, p1Action);
                    }

                    if (ballAnimRef.current.active) {
                        const { status, progress } = ballAnimRef.current;
                        const startX = w * 0.25, startY = h * 0.6;
                        const targetX = w * 0.75, targetY = h * 0.25;

                        if (status === 'flying') {
                            const p = ballAnimRef.current.progress;
                            const curX = startX + (targetX - startX) * p;
                            const curY = startY + (targetY - startY) * p - Math.sin(p * Math.PI) * 100;
                            drawPokeball(ctx, curX, curY, 24, p * Math.PI * 4, 'none');
                            ballAnimRef.current.progress = Math.min(1, p + 0.03);
                        } else {
                            const shakeOffset = Math.sin(Date.now() / 60) * 8;
                            const isActuallyShaking = (Date.now() % 700 < 350);
                            drawPokeball(ctx, targetX, targetY + 30, 24, isActuallyShaking ? shakeOffset * 0.02 : 0, status);
                        }
                    }

                    if (activeEffect) {
                        const tx = activeEffect.target === 'p2' ? w * 0.75 : w * 0.25;
                        const ty = activeEffect.target === 'p2' ? h * 0.25 : h * 0.7;
                        if (window.drawEffect) {
                            window.drawEffect(ctx, activeEffect, tx, ty, w, h);
                        }
                    }

                    const drawStatus = (x, y, data) => {
                        ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.roundRect(x, y, 220, 70, 12); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#1e293b'; ctx.font = 'bold 18px DotGothic16'; ctx.fillText(data.name, x + 15, y + 25);
                        ctx.fillStyle = '#cbd5e1'; ctx.fillRect(x + 15, y + 40, 190, 12);
                        const hpP = data.curHp / data.hp;
                        ctx.fillStyle = hpP > 0.5 ? '#22c55e' : hpP > 0.2 ? '#eab308' : '#ef4444';
                        ctx.fillRect(x + 15, y + 40, 190 * hpP, 12);
                        ctx.fillStyle = '#64748b'; ctx.font = '12px monospace'; ctx.fillText(`${Math.ceil(data.curHp)}/${data.hp}`, x + 150, y + 65);
                        ctx.restore();
                    };
                    drawStatus(30, 40, p2); drawStatus(w - 250, h - 110, p1);

                    ctx.restore();
                    animationId = requestAnimationFrame(render);
                };
                render();
                return () => cancelAnimationFrame(animationId);
            }, [gameState, p1, p2, activeEffect, shake, p1Action, p2Action]);

            // --- UI Components ---
            if (gameState === 'select') {
                return (
                    <div className="bg-slate-800 rounded-3xl border-4 border-slate-700 shadow-2xl text-white font-pixel flex flex-col max-h-[90vh] md:max-h-[85vh]">
                        <div className="p-4 md:p-6 pb-2 md:pb-4 flex-shrink-0">
                            <h1 className="text-2xl md:text-3xl text-center text-yellow-400 drop-shadow-md">ポケモンを えらぼう！</h1>
                        </div>
                        <div className="overflow-y-auto px-4 md:px-6 pb-4 md:pb-6 flex-1">
                            <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4">
                                {Object.entries(POKEMON_DATA).map(([key, data]) => (
                                    <button
                                        key={key}
                                        onClick={() => {
                                            const allKeys = Object.keys(POKEMON_DATA).filter(k => k !== key);
                                            const randomKey = allKeys[Math.floor(Math.random() * allKeys.length)];
                                            startBattle(key, randomKey);
                                        }}
                                        className="bg-slate-700 hover:bg-slate-600 border-4 border-transparent hover:border-yellow-400 p-4 rounded-2xl transition-all group flex flex-col items-center"
                                    >
                                        <img src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${data.id}.png`} className="w-32 h-32 group-hover:scale-110 transition-transform" />
                                        <span className="text-xl mt-2">{data.name}</span>
                                        <span className="text-xs text-slate-400 uppercase">{data.type} TYPE</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="bg-slate-800 rounded-3xl shadow-2xl overflow-hidden border-4 border-slate-600 select-none">
                    {/* BGM Player (YouTube IFrame - ユーザーインタラクション後に表示) */}
                    {bgmActive && (
                        <iframe
                            className="bgm-player"
                            src="https://www.youtube.com/embed/Q53CDIGPJ58?start=407&end=492&autoplay=1&loop=1&playlist=Q53CDIGPJ58&enablejsapi=1"
                            allow="autoplay; encrypted-media"
                            allowFullScreen={false}
                            onLoad={() => {
                                // iframeが読み込まれた後に音声コンテキストを開始
                                startAudio();
                            }}
                        ></iframe>
                    )}

                    {/* Header */}
                    <div className="bg-slate-900 p-3 text-white flex justify-between items-center px-4 md:px-8 border-b-2 border-slate-700">
                        <div className="flex items-center gap-2">
                            <div className={`w-3 h-3 rounded-full ${turn === 'player' ? 'bg-green-400 animate-pulse' : 'bg-slate-600'}`}></div>
                            <span className="text-sm font-bold tracking-widest">{p1.name}</span>
                        </div>
                        <span className="text-xs font-mono opacity-50 italic">VS WILD {p2.name}</span>
                    </div>

                    {/* Battle Canvas */}
                    <div className="relative bg-black overflow-hidden aspect-video">
                        <canvas ref={canvasRef} width={640} height={360} className="w-full h-full object-contain" />
                        {over && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center text-white p-4 animate-in fade-in duration-500">
                                <h2 className="text-5xl font-black mb-6 font-pixel text-yellow-400 italic text-center">
                                    {over === 'win' ? "勝利！" : over === 'caught' ? "つかまえた！" : "敗北..."}
                                </h2>
                                <button onClick={() => { setGameState('select'); setBgmActive(false); }} className="bg-white text-slate-900 px-10 py-3 rounded-full font-bold hover:bg-yellow-400 transition-all shadow-xl font-pixel">
                                    タイトルへ
                                </button>
                            </div>
                        )}
                    </div>

                    {/* Log Display */}
                    <div className="bg-slate-900 p-4 border-t-4 border-slate-700 h-32 md:h-40 font-pixel overflow-y-auto log-container flex flex-col-reverse shadow-inner">
                        <div>
                            {logs.map((log, i) => (
                                <div key={i} className={`mb-1 transition-all ${i === 0 ? "text-white text-xl md:text-2xl border-l-4 border-yellow-500 pl-3" : "text-slate-500 text-sm pl-4"}`}>
                                    {log}
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-0 border-t-4 border-slate-700 bg-slate-800">
                        {/* Move Set */}
                        <div className="grid grid-cols-2 gap-2 p-3 md:p-4 bg-slate-900/50 border-r-0 md:border-r-4 border-slate-700">
                            {p1.moves.map((move, idx) => (
                                <button
                                    key={move.name}
                                    onClick={() => executeTurn("player", idx)}
                                    disabled={turn !== "player" || busy || over}
                                    className={`p-3 md:p-4 text-xs md:text-sm font-bold rounded-xl border-2 transition-all pixel-border ${turn === "player" && !busy && !over ? "bg-slate-700 text-white border-slate-500 hover:border-yellow-400 active:translate-y-1" : "bg-slate-800 text-slate-600 border-transparent opacity-50"}`}
                                >
                                    {move.name}
                                </button>
                            ))}
                        </div>
                        {/* Sub Options */}
                        <div className="grid grid-cols-2 p-3 md:p-4 gap-2 md:gap-3 bg-slate-800">
                            <button
                                onClick={tryCatch}
                                disabled={turn !== "player" || busy || over}
                                className={`col-span-2 p-2 md:p-3 font-bold rounded-xl border-2 transition-all font-pixel text-sm shadow-lg ${turn === 'player' && !busy && !over ? 'bg-red-600 text-white border-red-400 hover:bg-red-500 active:translate-y-1' : 'bg-slate-800 text-slate-600 border-transparent opacity-50'}`}
                            >
                                モンスターボール
                            </button>
                            <button onClick={() => { setGameState('select'); setBgmActive(false); }} className="bg-slate-700 hover:bg-red-900 text-slate-300 hover:text-white border-2 border-slate-600 p-2 text-xs font-bold rounded-xl transition-all">にげる</button>
                            <div className="flex items-center justify-center bg-slate-900/40 rounded-xl border border-slate-700">
                                <span className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">{turn === "player" ? "Your Turn" : "CPU..."}</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>